# FlyCut Caption æŠ€æœ¯æ¶æ„

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FlyCut Caption Desktop App                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      å‰ç«¯å±‚ (React)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚   UI ç»„ä»¶    â”‚ â”‚   çŠ¶æ€ç®¡ç†   â”‚ â”‚   ä¸šåŠ¡é€»è¾‘   â”‚            â”‚
â”‚  â”‚ Shadcn/ui   â”‚ â”‚   Zustand   â”‚ â”‚   Hooks     â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    é€šä¿¡å±‚ (Tauri IPC)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     åç«¯å±‚ (Rust)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  AI å¤„ç†æ¨¡å—  â”‚ â”‚ è§†é¢‘å¤„ç†æ¨¡å—  â”‚ â”‚ æ–‡ä»¶ç³»ç»Ÿæ¨¡å—  â”‚            â”‚
â”‚  â”‚ whisper.cpp â”‚ â”‚   FFmpeg    â”‚ â”‚  File APIs  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     ç³»ç»Ÿèµ„æºå±‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚   GPU åŠ é€Ÿ   â”‚ â”‚   æœ¬åœ°å­˜å‚¨   â”‚ â”‚   ç³»ç»Ÿ API   â”‚            â”‚
â”‚  â”‚ CUDA/Metal  â”‚ â”‚   Models    â”‚ â”‚  Notificationsâ”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¨ å‰ç«¯æ¶æ„ (ä¿æŒä¸å˜)

### ç»„ä»¶å±‚æ¬¡ç»“æ„

```
App.tsx
â”œâ”€â”€ FileUpload/                 # æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”œâ”€â”€ ProcessingPanel/            # å¤„ç†é¢æ¿
â”‚   â”œâ”€â”€ ASRPanel               # ASR è¯†åˆ«é¢æ¿
â”‚   â””â”€â”€ LanguageSelector       # è¯­è¨€é€‰æ‹©å™¨
â”œâ”€â”€ VideoPlayer/               # è§†é¢‘æ’­æ”¾å™¨
â”‚   â””â”€â”€ EnhancedVideoPlayer    # å¢å¼ºè§†é¢‘æ’­æ”¾å™¨
â”œâ”€â”€ SubtitleEditor/            # å­—å¹•ç¼–è¾‘å™¨
â”‚   â”œâ”€â”€ SubtitleList          # å­—å¹•åˆ—è¡¨
â”‚   â””â”€â”€ SubtitleItem          # å­—å¹•é¡¹
â”œâ”€â”€ ExportPanel/               # å¯¼å‡ºé¢æ¿
â””â”€â”€ MessageCenter/             # æ¶ˆæ¯ä¸­å¿ƒ
    â”œâ”€â”€ MessageCard           # æ¶ˆæ¯å¡ç‰‡
    â””â”€â”€ ToastContainer        # é€šçŸ¥å®¹å™¨
```

### çŠ¶æ€ç®¡ç†æ¶æ„

```typescript
// Zustand Stores
â”œâ”€â”€ appStore.ts                # åº”ç”¨å…¨å±€çŠ¶æ€
â”œâ”€â”€ historyStore.ts            # å­—å¹•å†å²ç®¡ç†
â”œâ”€â”€ themeStore.ts              # ä¸»é¢˜ç®¡ç†
â””â”€â”€ messageStore.ts            # æ¶ˆæ¯ç®¡ç†
```

### æ ¸å¿ƒ Hooks

```typescript
â”œâ”€â”€ useHotkeys.ts              # çƒ­é”®ç®¡ç†
â”œâ”€â”€ useASR.ts                  # ASR å¤„ç† (éœ€è¦é€‚é…)
â””â”€â”€ useVideoProcessing.ts      # è§†é¢‘å¤„ç† (éœ€è¦é€‚é…)
```

## ğŸ¦€ åç«¯æ¶æ„ (Tauri + Rust)

### é¡¹ç›®ç»“æ„

```
src-tauri/
â”œâ”€â”€ Cargo.toml                 # Rust ä¾èµ–é…ç½®
â”œâ”€â”€ tauri.conf.json            # Tauri é…ç½®
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs               # åº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ commands/             # Tauri å‘½ä»¤æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ asr.rs            # ASR ç›¸å…³å‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ video.rs          # è§†é¢‘å¤„ç†å‘½ä»¤
â”‚   â”‚   â””â”€â”€ file.rs           # æ–‡ä»¶æ“ä½œå‘½ä»¤
â”‚   â”œâ”€â”€ services/             # ä¸šåŠ¡æœåŠ¡å±‚
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ whisper_service.rs # Whisper æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ ffmpeg_service.rs  # FFmpeg æœåŠ¡
â”‚   â”‚   â””â”€â”€ cache_service.rs   # ç¼“å­˜æœåŠ¡
â”‚   â”œâ”€â”€ models/               # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ transcript.rs     # è½¬å½•æ•°æ®æ¨¡å‹
â”‚   â”‚   â””â”€â”€ video.rs          # è§†é¢‘æ•°æ®æ¨¡å‹
â”‚   â””â”€â”€ utils/                # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ path_utils.rs     # è·¯å¾„å¤„ç†
â”‚       â””â”€â”€ config.rs         # é…ç½®ç®¡ç†
â”œâ”€â”€ models/                   # AI æ¨¡å‹å­˜å‚¨
â”‚   â”œâ”€â”€ whisper-base.bin
â”‚   â”œâ”€â”€ whisper-small.bin
â”‚   â””â”€â”€ whisper-medium.bin
â””â”€â”€ binaries/                 # å¤–éƒ¨äºŒè¿›åˆ¶æ–‡ä»¶
    â”œâ”€â”€ ffmpeg
    â””â”€â”€ ffprobe
```

### æ ¸å¿ƒæœåŠ¡æ¨¡å—

#### 1. ASR æœåŠ¡æ¨¡å—

```rust
// src-tauri/src/services/whisper_service.rs
use whisper_rs::{FullParams, SamplingStrategy, WhisperContext};

pub struct WhisperService {
    context: WhisperContext,
    model_path: PathBuf,
}

impl WhisperService {
    pub fn new(model_path: PathBuf) -> Result<Self, WhisperError> {
        let context = WhisperContext::new(&model_path)?;
        Ok(Self { context, model_path })
    }

    pub async fn transcribe(
        &self,
        audio_path: &str,
        language: Option<&str>,
    ) -> Result<TranscriptResult, WhisperError> {
        // Whisper è½¬å½•å®ç°
        let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });
        
        if let Some(lang) = language {
            params.set_language(Some(lang));
        }
        
        // æ‰§è¡Œè½¬å½•
        let result = self.context.full(params, audio_samples)?;
        
        // è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
        Ok(self.convert_to_transcript_result(result))
    }
}
```

#### 2. è§†é¢‘å¤„ç†æœåŠ¡

```rust
// src-tauri/src/services/ffmpeg_service.rs
use std::process::Command;

pub struct FFmpegService {
    ffmpeg_path: PathBuf,
}

impl FFmpegService {
    pub fn new(ffmpeg_path: PathBuf) -> Self {
        Self { ffmpeg_path }
    }

    pub async fn export_video(
        &self,
        input: &str,
        segments: &[TimeSegment],
        output: &str,
        quality: VideoQuality,
    ) -> Result<String, FFmpegError> {
        // æ„å»º FFmpeg å‘½ä»¤
        let mut cmd = Command::new(&self.ffmpeg_path);
        
        // æ·»åŠ è¾“å…¥æ–‡ä»¶
        cmd.arg("-i").arg(input);
        
        // æ·»åŠ ç‰‡æ®µè¿‡æ»¤å™¨
        let filter = self.build_segment_filter(segments);
        cmd.arg("-vf").arg(filter);
        
        // æ·»åŠ è´¨é‡è®¾ç½®
        self.apply_quality_settings(&mut cmd, quality);
        
        // è¾“å‡ºæ–‡ä»¶
        cmd.arg(output);
        
        // æ‰§è¡Œå‘½ä»¤
        let output = cmd.output().await?;
        
        if output.status.success() {
            Ok(output.to_string())
        } else {
            Err(FFmpegError::ProcessingFailed(
                String::from_utf8_lossy(&output.stderr).to_string()
            ))
        }
    }

    fn build_segment_filter(&self, segments: &[TimeSegment]) -> String {
        // æ„å»ºå¤æ‚çš„ FFmpeg è¿‡æ»¤å™¨
        // ä¾‹å¦‚: "select='between(t,0,10)+between(t,15,25)',setpts=N/FRAME_RATE/TB"
        segments.iter()
            .map(|seg| format!("between(t,{},{})", seg.start, seg.end))
            .collect::<Vec<_>>()
            .join("+")
    }
}
```

### Tauri å‘½ä»¤æ¥å£

```rust
// src-tauri/src/commands/asr.rs
use crate::services::WhisperService;

#[tauri::command]
pub async fn transcribe_audio(
    audio_path: String,
    model: String,
    language: Option<String>,
    app_handle: tauri::AppHandle,
) -> Result<TranscriptResult, String> {
    let whisper_service = app_handle.state::<WhisperService>();
    
    whisper_service
        .transcribe(&audio_path, language.as_deref())
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_available_models() -> Result<Vec<ModelInfo>, String> {
    // è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
    Ok(vec![
        ModelInfo { name: "base".to_string(), size: "74MB".to_string() },
        ModelInfo { name: "small".to_string(), size: "244MB".to_string() },
        ModelInfo { name: "medium".to_string(), size: "769MB".to_string() },
    ])
}

#[tauri::command]
pub async fn download_model(
    model_name: String,
    app_handle: tauri::AppHandle,
) -> Result<(), String> {
    // æ¨¡å‹ä¸‹è½½é€»è¾‘
    // æ”¯æŒè¿›åº¦å›è°ƒåˆ°å‰ç«¯
    Ok(())
}
```

## ğŸ”„ å‰åç«¯é€šä¿¡

### IPC é€šä¿¡æ¨¡å¼

```typescript
// å‰ç«¯è°ƒç”¨åç«¯
import { invoke } from '@tauri-apps/api/tauri';

// ASR è½¬å½•
const result = await invoke<TranscriptResult>('transcribe_audio', {
  audioPath: file.path,
  model: 'base',
  language: 'zh'
});

// è§†é¢‘å¯¼å‡º
const outputPath = await invoke<string>('export_video', {
  inputPath: video.path,
  segments: keptSegments,
  outputPath: savePath,
  quality: 'high'
});

// è¿›åº¦ç›‘å¬
import { listen } from '@tauri-apps/api/event';

await listen('transcription-progress', (event) => {
  console.log('Progress:', event.payload);
});
```

### äº‹ä»¶ç³»ç»Ÿ

```rust
// åç«¯å‘é€è¿›åº¦äº‹ä»¶
use tauri::Manager;

pub async fn transcribe_with_progress(
    app_handle: tauri::AppHandle,
    audio_path: String,
) -> Result<TranscriptResult, String> {
    let window = app_handle.get_window("main").unwrap();
    
    // å‘é€è¿›åº¦æ›´æ–°
    window.emit("transcription-progress", ProgressPayload {
        current: 50,
        total: 100,
        message: "Processing audio...".to_string(),
    }).unwrap();
    
    // ç»§ç»­å¤„ç†...
    Ok(result)
}
```

## ğŸ“¦ èµ„æºç®¡ç†

### æ¨¡å‹ç¼“å­˜ç­–ç•¥

```
~/.flycut-caption/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ whisper-base.bin
â”‚   â”œâ”€â”€ whisper-small.bin
â”‚   â””â”€â”€ whisper-medium.bin
â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ audio-extracts/
â”‚   â””â”€â”€ temp-videos/
â””â”€â”€ config.json
```

### é…ç½®ç®¡ç†

```rust
// src-tauri/src/utils/config.rs
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Default)]
pub struct AppConfig {
    pub preferred_model: String,
    pub output_quality: String,
    pub cache_dir: PathBuf,
    pub hardware_acceleration: bool,
}

impl AppConfig {
    pub fn load() -> Result<Self, ConfigError> {
        let config_path = Self::config_path()?;
        if config_path.exists() {
            let content = std::fs::read_to_string(config_path)?;
            Ok(serde_json::from_str(&content)?)
        } else {
            Ok(Self::default())
        }
    }

    pub fn save(&self) -> Result<(), ConfigError> {
        let config_path = Self::config_path()?;
        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(config_path, content)?;
        Ok(())
    }
}
```

## ğŸ”§ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å¹¶å‘å¤„ç†

```rust
// ä½¿ç”¨ Tokio å¼‚æ­¥è¿è¡Œæ—¶
use tokio::task;

pub async fn process_multiple_segments(
    segments: Vec<TimeSegment>
) -> Result<Vec<ProcessedSegment>, ProcessingError> {
    let tasks = segments.into_iter()
        .map(|segment| {
            task::spawn(async move {
                process_single_segment(segment).await
            })
        })
        .collect::<Vec<_>>();

    let results = futures::future::try_join_all(tasks).await?;
    Ok(results)
}
```

### 2. å†…å­˜ç®¡ç†

```rust
// æµå¼å¤„ç†å¤§æ–‡ä»¶
use tokio::fs::File;
use tokio::io::{AsyncReadExt, BufReader};

pub async fn process_large_video(
    input_path: &str,
    chunk_size: usize,
) -> Result<(), ProcessingError> {
    let file = File::open(input_path).await?;
    let mut reader = BufReader::new(file);
    let mut buffer = vec![0; chunk_size];
    
    while reader.read_exact(&mut buffer).await.is_ok() {
        // åˆ†å—å¤„ç†è§†é¢‘æ•°æ®
        process_chunk(&buffer).await?;
    }
    
    Ok(())
}
```

### 3. ç¼“å­˜ç­–ç•¥

```rust
use std::collections::HashMap;
use tokio::sync::RwLock;

pub struct CacheService {
    cache: RwLock<HashMap<String, CachedResult>>,
    max_size: usize,
}

impl CacheService {
    pub async fn get_or_compute<T, F>(
        &self,
        key: &str,
        compute_fn: F,
    ) -> Result<T, CacheError>
    where
        F: Future<Output = Result<T, CacheError>>,
        T: Clone + Serialize + DeserializeOwned,
    {
        // å…ˆæ£€æŸ¥ç¼“å­˜
        {
            let cache = self.cache.read().await;
            if let Some(cached) = cache.get(key) {
                if !cached.is_expired() {
                    return Ok(cached.data.clone());
                }
            }
        }
        
        // è®¡ç®—ç»“æœ
        let result = compute_fn.await?;
        
        // å­˜å…¥ç¼“å­˜
        {
            let mut cache = self.cache.write().await;
            cache.insert(key.to_string(), CachedResult::new(result.clone()));
        }
        
        Ok(result)
    }
}
```

## ğŸš€ éƒ¨ç½²æ¶æ„

### æ„å»ºç®¡é“

```yaml
# .github/workflows/build.yml
name: Build and Release
on:
  push:
    tags: ['v*']

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          
      - name: Install dependencies
        run: |
          pnpm install
          
      - name: Build application
        run: |
          pnpm tauri build
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ matrix.os }}
          path: src-tauri/target/release/bundle/
```

### è‡ªåŠ¨æ›´æ–°æœºåˆ¶

```rust
// src-tauri/src/commands/update.rs
use tauri_plugin_updater::UpdaterExt;

#[tauri::command]
pub async fn check_for_updates(app: tauri::AppHandle) -> Result<UpdateInfo, String> {
    let updater = app.updater();
    
    match updater.check().await {
        Ok(Some(update)) => {
            Ok(UpdateInfo {
                available: true,
                version: update.version,
                notes: update.body.unwrap_or_default(),
                download_url: update.download_url,
            })
        }
        Ok(None) => Ok(UpdateInfo::no_update()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn install_update(app: tauri::AppHandle) -> Result<(), String> {
    let updater = app.updater();
    
    if let Some(update) = updater.check().await.map_err(|e| e.to_string())? {
        update.download_and_install().await.map_err(|e| e.to_string())?;
    }
    
    Ok(())
}
```

è¿™ä¸ªæ¶æ„è®¾è®¡ç¡®ä¿äº†ï¼š
- **å‰ç«¯é›¶æ”¹åŠ¨**: ç°æœ‰ React ä»£ç å®Œå…¨ä¿ç•™
- **é«˜æ€§èƒ½**: æœ¬åœ°å¤„ç† + ç¡¬ä»¶åŠ é€Ÿ
- **å¯ç»´æŠ¤æ€§**: æ¸…æ™°çš„æ¨¡å—åŒ–è®¾è®¡
- **å¯æ‰©å±•æ€§**: æ’ä»¶åŒ–çš„æœåŠ¡æ¶æ„
- **ç”¨æˆ·ä½“éªŒ**: åŸç”Ÿåº”ç”¨çº§åˆ«çš„ä½“éªŒ